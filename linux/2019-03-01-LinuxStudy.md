# Linux

> 命令格式：command -options arguments

*tabel 0: Linux 系统中的目录*

| 目录           | 评论                                                         |
| -------------- | ------------------------------------------------------------ |
| /              | 根目录，万物起源。                                           |
| /bin           | 包含系统启动和运行所必须的二进制程序。                       |
| /boot          | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。 |
| /dev           | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 |
| /etc           | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。 |
| /home          | 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 |
| /lib           | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 |
| /lost+found    | 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 |
| /media         | 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 |
| /mnt           | 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。     |
| /opt           | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 |
| /proc          | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 |
| /root          | root 帐户的家目录。                                          |
| /sbin          | 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 |
| /tmp           | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。 |
| /usr           | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 |
| /usr/bin       | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 |
| /usr/lib       | 包含由/usr/bin 目录中的程序所用的共享库。                    |
| /usr/local     | 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 |
| /usr/sbin      | 包含许多系统管理程序。                                       |
| /usr/share     | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 |
| /usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 |
| /var           | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 |
| /var/log       | 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 |

## 学习 shell

- 鼠标中键 = 粘贴
- date 输出当前日期； cal 按月份输出当前月份和日期
- 查看磁盘剩余空间的数量，输入 df 
- 显示空闲内存的数量，输入命令 free 
- pwd - Print name of current working directory
- cd - Change directory

| 快捷键        | 运行结果                                                     |
| ------------- | ------------------------------------------------------------ |
| cd            | 更改工作目录到你的家目录。                                   |
| cd -          | 更改工作目录到先前的工作目录。                               |
| cd ~user_name | 更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。 |

- ls - List directory contents
  - ls -a 包括隐藏文件（.xxx）
  - ls -l 列表的方式

*table 1-1: ls 命令选项*

| 选项 | 长选项           | 描述                                                         |
| ---- | ---------------- | ------------------------------------------------------------ |
| -a   | --all            | 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 |
| -d   | --directory      | 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 |
| -F   | --classify       | 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。 |
| -h   | --human-readable | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 |
| -l   |                  | 以长格式显示结果。                                           |
| -r   | --reverse        | 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 |
| -S   |                  | 命令输出结果按照文件大小来排序。                             |
| -t   |                  | 按照修改时间来排序。                                         |

*table 1-2: ls 长格式列表的字段（ls -l）*

```linux
-rw-r--r-- 1 root root   32059 2007-04-03 11:05 oo-cd-cover.odf
```

| 字段             | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| -rw-r--r--       | 对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。 |
| 1                | 文件的硬链接数目。参考随后讨论的关于链接的内容。             |
| root             | 文件所有者的用户名。                                         |
| root             | 文件所属用户组的名字。                                       |
| 32059            | 以字节数表示的文件大小。                                     |
| 2007-04-03 11:05 | 上次修改文件的时间和日期。                                   |
| oo-cd-cover.odf  | 文件名。                                                     |

- file & less
  - file — 确定文件类型（file filename）
  - less — 浏览文件内容（less filename）

*table 1-3: less 命令*

| 命令               | 行为                                                     |
| ------------------ | -------------------------------------------------------- |
| Page UP or b       | 向上翻滚一页                                             |
| Page Down or space | 向下翻滚一页                                             |
| UP Arrow           | 向上翻滚一行                                             |
| Down Arrow         | 向下翻滚一行                                             |
| G                  | 移动到最后一行                                           |
| 1G or g            | 移动到开头一行                                           |
| /charaters         | 向前查找指定的字符串                                     |
| n                  | 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
| h                  | 显示帮助屏幕                                             |
| q                  | 退出 less 程序                                           |

## bash 脚本

bash 还提供了一种名为追踪的方法，这种方法可通过 -x 选项和 set 命令加上 -x 选项两种途径实现。 拿我们之前的 trouble 脚本为例，给该脚本的第一行语句添加 -x 选项，我们就能追踪整个脚本。

```shell
#!/bin/bash -x
# trouble: script to demonstrate common errors
number=1
if [ $number = 1 ]; then
    echo "Number is equal to 1."
else
    echo "Number is not equal to 1."
fi
```

我们可以使用 set 命令加上 -x 选项，为脚本中的一块选择区域，而不是整个脚本启用追踪。

```shell
#!/bin/bash
# trouble: script to demonstrate common errors
number=1
set -x # Turn on tracing
if [ $number = 1 ]; then
    echo "Number is equal to 1."
else
    echo "Number is not equal to 1."
fi
set +x # Turn off tracing
```

我们使用 set 命令加上 -x 选项来启动追踪，+x 选项关闭追踪。这种技术可以用来检查一个有错误的脚本的多个部分。

## for 循环解释

```shell
for (( expression1; expression2; expression3 )); do
    commands
done


(( expression1 ))
while (( expression2 )); do
    commands
    (( expression3 ))
done
```

## 常用命令

- 查看当前系统的发型版本

  ```
  cat /etc/issue 
  lsb_release -a cat 
  /etc/redhat-release(这种方法只适合 Redhat 系的 Linux)
  ```

- 查看当前目录下文件大小：`du -sh * `

- `ls -altF` 

  已列表的方式显示所有的文件，按修改时间排序，如果是目录会加上/  

- tab 两下，会列出所有匹配项

- 如果你在 vi 中“迷失”了，试着按下 Esc 键两次来回到普通模式
- touch：更改文件时间 
- stat：显示文件或文件系统状态



## Vim

u: 撤销上一步

### 插入

a: 在光标下个位置插入

A: 在行尾插入

o: 当前行的下方打开一行

O: 当前行的上方打开一行

### 删除

x: 当前字符

3x: 当前字符及其后的两个字符。

dd: 当前行。

5dd: 当前行及随后的四行文本。

dW: 从光标位置开始到下一个单词的开头。

d$: 从光标位置开始到当前行的行尾。

d0: 从光标位置开始到当前行的行首。

d^: 从光标位置开始到文本行的第一个非空字符。

dG: 从当前行到文件的末尾。

d20G: 从当前行到文件的第20行。

p: 命令把剪切板中的文本粘贴到光标位置之后

P: 命令把文本粘贴到光标之前

### 复制的内容

yy: 当前行

5yy: 当前行及随后的四行文本

yW: 从当前光标位置到下一个单词的开头

y$: 从当前光标位置到当前行的末尾

y0: 从当前光标位置到行首

y^: 从当前光标位置到文本行的第一个非空字符

yG: 从当前行到文件末尾

y20G: 从当前行到文件的第20行

### 移动、查找

J: 把下一行移动到当前行末尾

/: 查找单词或短语，重复键入 n 命令，光标会继续向下移动直到遍历所有的匹配项

### 切换

打开2个文件，在这2个文件之间切换

```
vim test1 test2  
:n 切换到下一个文件   
:N 切换回第一个文件   
:w test1.txt 另存为 test1.txt 
```

### 查找

locate – 通过名字来查找文件
find – 在一个目录层次结构中搜索文件
	`find ~ -type d` 搜索家目录的所有文件夹
	`find ~ -type f` 搜索家目录的所有文件
	`find ~ -type f -name "*.JPG" -size +1M`  让我们查找所有文件名匹配 通配符模式“*.JPG”和文件大小大于1M 的普通文件。我们加入 -size 测试条件，后跟字符串“+1M”。开头的加号表明 我们正在寻找文件大小大于指定数的文件。若字符串以减号开头，则意味着查找小于指定数的文件。 若没有符号意味着“精确匹配这个数”。 -iname 不区分大小写
	find ~ -type f -name '*.BAK' -delete 用户家目录（和它的子目录）下的每个文件中搜索以.BAK 结尾的文件名。当找到后，就删除它们。 警告：当使用 -delete 操作时，不用说，你应该格外小心。每次都应该首先用 -print 操作代替 -delete 测试一下命令，来确认搜索结果。