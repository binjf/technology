## 2018 java 面试题

### 1 String能被继承吗？为什么？

不可以，因为String类有final修饰符，而final不能被继承的，实现细节不允许改变。平常我们定义的 `String str = " a ";` 其实和 `String str = new String("a");` 还是有差异的。前者默认调用的 `String.valueof` 来返回 String 的实例对象，至于调用哪个则取决于你的赋值，比如 `String num = 1; `调用的是

```java
public static String valueOf(int i){
	return Integer.toString(i);
}
```

后者则是调用如下部分:

```java
public String(String original) { 
    this.value = original.value; 
    this.hash = original.hash; 
} 
```

最后我们的变量都存储在一个char数组中：`private final char value[];`

### 2 String,  Stringbuffer, StringBuilder 的区别

String 字符串常量（final修饰，不可被继承），String 是常量，当创建之后即不能更改。可以通过 StringBuffer 和 StringBuilder 创建 String 对象（常用的两个字符串操作类）。 StringBuffer 字符串变量（线程安全），其也是 final 类别的，不允许被继承，其中的绝大多数方法都进行了同步处理，包括常用的 append 方法也做了同步处理,其自 jdk1.0 起就已经出现。其 toString 方法会进行对象缓存，以减少元素的复制开销。

```java
public synchronized String toString() { 
    if (toStringCache == null) { 
     	toStringCache = Arrays.copyOfRange(value, 0, count); 
    } 
    return new String(toStringCache, true); 
}
```

`StringBuilder` 字符串变量，（非线程安全）其自 jdk1.5 起开始出现。与 `StringBuffer`一样都继承和实现同一个接口和类，方法除了没有使用 synch 修饰以外基本一致，不同之处在于最后 toString 的时候，会直接返回一个新对象。

```java
public String toString() { 
 // Create a copy, don’t share the array 
 return new String(value, 0, count); 
 }
```

### 3 ArrayList 和 LinkedList 有什么区别

ArrayList和LinkedList都实现了List接口，有以下的不同点： 

- ArrayList

  ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。以此对应，LinkedList是以元素列表的形式存储的数据，每一个元素都和它的前一个后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 

- LinkedList

  相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。

- 区别

  LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

### 4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序

父类静态代变量
父类静态代码块
子类静态变量
子类静态代码块
父类非静态变量（父类实例成员变量）
父类构造函数、 
子类非静态变量（子类实例成员变量） 
子类构造函数

### 5 用过哪些 Map 类，都有什么区别，HashMap 是线程安全的吗,并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式， hashcode，扩容， 默认容量等

hashMap是线程不安全的，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，采用哈希表来存储的，JAVA8 的 ConcurrentHashMap 为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。有没有顺序的Map实现类，如果有，他们是怎么保证有序的。TreeMap和LinkedHashMap是有序的（TreeMap默认升序，LinkedHashMap则记录了插入顺序）。

### 6 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 
2、抽象类要被子类继承，接口要被类实现。　　
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该        类也只能为抽象类。 
6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 
7、抽象类里可以没有抽象方法 。
8、如果一个类里有抽象方法，那么这个类只能是抽象类 。
9、抽象方法要被实现，所以不能是静态的，也不能是私有的。 
10、接口可继承接口，并可多继承接口，但类只能单根继承。

### 7 继承和聚合的区别在哪

继承指的是一个类（称为子类、子类接口）继承另外一个类（称为父类、父接口）的功能，并可以增加它自己的新功能，继承是类与类或者接口之间最常见的关系。在java中此类关系通过关键字exetents明确标识，在设计时候一般没有争议性。

### 8 Java中java.util.Comparator接口简单描述一下

java.util.Comparator是比较器接口，如果我们需要控制某个类的次序并且该类本身不支持排序，那么就可以建立一个类比较器来进行排序，实现方式很简单只需要实现java.util.Comparator接口。

java.util.Comparator接口只包括两个函数，它的源码如下：

> package java.util;    
>
> public interface Comparator<T> {    
>
>     int compare(T o1, T o2);    
>     
>     boolean equals(Object obj);    
>
> }    



1）若一个类要实现java.util.Comparator接口：它一定要实现int compare(T o1, T o2) 函数，而另一个可以不实现boolean equals(Object obj) 函数

2）int compare(T o1, T o2) 是比较o1和o2的大小

如果返回值为负数意味着o1比o2小，否则返回为零意味着o1等于o2，返回为正数意味着o1大于o2

### 9 String 类为什么是 final 的

答案一：
String类型是对象类型，在静态方法下必须调用静态方法或值，如果非静态的方法，必须实例化；
main函数是static的，所以String可以和其他类型一样被直接调用，不会报错误的原因

答案二：
主要考虑到“安全”和“效率”的缘故，若String允许被继承，那么它的高度使用率可能会降低程序的性能，因此String被定义成了final。

### 10 什么是序列化以及用途，什么时候使用序列化

序列化是指把对象转换为字节序列的过程称为对象的序列化；而反序列化是指把字节序列恢复为对象的过程称为对象的反序列化。

对象的序列化主要有两种用途：

- 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；

- 在网络上传送对象的字节序列。

什么时候使用序列化：

- 对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。

- java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的"深复制"，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。

### 11 用简洁的话描述一下关于Spring的IOC与AOP

IoC就是对象的创建，依赖都由Spring及配置文件控制；而AOP就是统一的给一些类似的方法加上同样的功能，比如日志，事务。

IOC：控制反转，是一种设计模式。一层含义是控制权的转移：由传统的在程序中控制依赖转移到由容器来控制；

第二层是依赖注入：将相互依赖的对象分离，在spring配置文件中描述他们的依赖关系。他们的依赖关系只在使用的时候才建立。

AOP：面向切面，是一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。比如事务、日志和安全等。

### 12 Java虚拟机内存的堆区（heap），栈区（stack）和静态区（static/method）

JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)

堆区：

- 存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)

- jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身.

- 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

栈区：

- 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中

- 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。

- 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。

- 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。

静态区别名方法区：

- 方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。

- 方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。

- 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。

### 13 Java中HashMap和HashTable的区别

HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），他们都完成了 Map 接口，主要区别在于HashMap 允许空（null）键值（key）,由于非线程安全，效率上可能高于 Hashtable。HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。

HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsvalue 和 containsKey。因为 contains 方法容易让人引起误解。 Hashtable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。

最大的不同是，Hashtable 方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步(Collections.synchronizedMap)。 

Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。

### 14 cookie 和 session 的的区别有哪些

COOKIE 数据存放在客户的浏览器上，而 session 数据放在服务器上；

COOKIE 分发是通过扩展 HTTP 协议来实现的，服务器通过在 HTTP 的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的 COOKIE

COOKIE不是很安全，可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，出于安全考虑应当使用 session；

session会在一定时间内保存在服务器上，当访问增多时会比较影响服务器的性能，出于考虑减轻服务器性能方面，应当使用 COOKIE；

单个COOKIE保存的数据不能超过4K，大多说浏览器都限制了一个站点最多保存20个 COOKIE

个人观点认为将一些登录信息（重要信息）存放在 session 中，而其他信息如果需要保留，可以放在 COOKIE 中

### 15 Java 面向对象的特征有哪些方面

- 抽象

  抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。

- 继承：

  继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。

- 封装：

  封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一 系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。

- 多态性

  多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享 、代码共享的优势，很好的解决了应用程序函数同名问题。

### 16 int 类型和 Integer 类型有什么区别

Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。 

Java为每个原始类型提供了封装类，原始类型封装类具体如下：

> booleanBoolean    
>
> charCharacter    
>
> byteByte    
>
> shortShort    
>
> intInteger    
>
> longLong    
>
> floatFloat    
>
> doubleDouble    

引用类型和原始类型的行为完全不同，并且它们具有不同的语义。

引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。

对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。

### 17 String、StringBuffer与StringBuilder的区别

java 提供了两个类：String和StringBuffer，java 5.0新增java.lang.StringBuilder一个可变的字符序列。

简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。

- java.lang.StringBuffer

  StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。

- java.lang.String

  在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。

- java.lang.StringBuilde

  java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

### 18 编程题：写一个 Singleton 单例模式

Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在，一般Singleton模式通常有几种种形式:

第一种形式： 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。

```java
public class Singleton {    

private Singleton(){}    

   //在自己内部定义自己一个实例，是不是很奇怪？    

　　 //注意这是private 只供内部调用    

　　 private static Singleton instance = new Singleton();    

　　 //这里提供了一个供外部访问本class的静态方法，可以直接访问　　    

　 public static Singleton getInstance() {    

　　　　 return instance; 　　    

  }     

}    
```

第二种形式： 

```java
public class Singleton {     

　　private static Singleton instance = null;    

　　public static synchronized Singleton getInstance() {    

　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次    

　　//使用时生成实例，提高了效率！    

　　if (instance==null)    

　　　　instance＝new Singleton();    

return instance;    

　　}     

}   
```

其他形式：

定义一个类，它的构造函数为private的，所有方法为static的，一般认为第一种形式要更加安全些。

### 19 运行时异常与一般异常有何异同

异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。

java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。

### 20 说出Servlet的生命周期，并说出Servlet和CGI的区别

Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方 法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一 般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。

### 21 说出ArrayList,Vector, LinkedList的存储性能和特性

ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索 引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程 安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数 据时只需要记录本项的前后项即可，所以插入速度较快。

### 22 Collection 和 Collections的区别

Collection是集合类的上级接口，继承与他的接口主要有Set 和List。

Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

### 23 final，finally， finalize有什么区别

final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

finally 是异常处理语句结构的一部分，表示总是执行。

finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

### 24 请说出你所知道的线程同步的方法

wait()：使一个线程处于等待状态，并且释放所持有的对象的lock。

sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。

notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。

Allnotity()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

### 25 Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型

方法的重写Overriding和重载Overloading是Java多态性的不同表现。

重写Overriding是父类与子类之间多态性的一种表现，重载 Overloading是一个类中多态性的一种表现。

如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写  (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。

如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改 变返回值的类型。

### abstract class和interface有什么区别

声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建 abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。

Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。

接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。

### 同步和异步有何异同，在什么情况下分别使用他们？举例说明

如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

### forward 和 redirect 两者有什么区别

forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。

redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所session,request参数都可以获取。

### GC是什么? 为什么要有GC

GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

### 启动一个线程是用run()还是start()

启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线 程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。

### 说一说你在开发过程中最常见到的 runtime exception 异常

ArithmeticException, 

ArrayStoreException, 

BufferOverflowException,

 BufferUnderflowException, 

CannotRedoException,  

CannotUndoException, 

ClassCastException, 

CMMException, 

ConcurrentModificationException, 

DOMException,  

EmptyStackException, 

IllegalArgumentException, 

IllegalMonitorStateException, 

IllegalPathStateException,  

IllegalStateException, 

ImagingOpException,

IndexOutOfBoundsException, 

MissingResourceException,  

NegativeArraySizeException, 

NoSuchElementException, 

NullPointerException, 

ProfileDataException, 

ProviderException,  

RasterFormatException, 

SecurityException, 

SystemException, 

UndeclaredThrowableException, 

UnmodifiableSetException,  

UnsupportedOperationException

### 说出数据连接池的工作机制是什么

J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。

### swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上

JDk1.7之前 switch（expr1）函数中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。 

注意，对于精度比int大的类型，比如long、float，doulble，不会自动转换为int，如果想使用，就必须强转为int，如(int)float。

jdk1.7后，整型，枚举类型，boolean，字符串都可以。jdk1.7并没有新的指令来处理switch string，而是通过调用switch中string.hashCode,将string转换为int从而进行判断。

### Java的接口和C++的虚类的相同和不同处

由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。

### Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()，它们有何区别

Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。

equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。

### Java中的异常处理机制的简单原理和应用

当 JAVA 程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。

一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。

另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable的子类。

### 垃圾回收的优点和原理，并考虑2种回收机制

Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。

垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

### 请说出你所知道的线程同步的方法

wait():使一个线程处于等待状态，并且释放所持有的对象的lock。

sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。

notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。

allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

### XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式

1） 两种形式 dtd schema

2）本质区别：schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)

3）有DOM,SAX,STAX等

DOM：处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问

SAX：不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 

STAX： Streaming API for XML (StAX)

xml文档有两种定义方法：

- dtd

  数据类型定义（data type definition），用以描述XML文档的文档结构，是早期的XML文档定义形式。

- schema

  其本身是基于XML语言编写的，在类型和语法上的限定能力比dtd强，处理也比较方便，因为此正逐渐代替dtd成为新的模式定义语言。

### Servlet执行时一般实现哪几个方法

```java
public void init(ServletConfig config)    
public ServletConfig getServletConfig()    
public String getServletInfo()    
public void service(ServletRequest request,ServletResponse response)    
public void destroy()     
```

init ()方法在servlet的生命周期中仅执行一次，在服务器装载servlet时执行。缺省的init()方法通常是符合要求的，不过也可以根据需要进行 override，比如管理服务器端资源，一次性装入GIF图像，初始化数据库连接等，缺省的inti()方法设置了servlet的初始化参数，并用它的ServeltConfig对象参数来启动配置，所以覆盖init()方法时，应调用super.init()以确保仍然执行这些任务。

service ()方法是servlet的核心，在调用service()方法之前，应确保已完成init()方法。对于HttpServlet，每当客户请求一个HttpServlet对象，该对象的service()方法就要被调用，HttpServlet缺省的service()方法的服务功能就是调用与 HTTP请求的方法相应的do功能，doPost()和doGet()，所以对于HttpServlet，一般都是重写doPost()和doGet() 方法。

destroy()方法在servlet的生命周期中也仅执行一次，即在服务器停止卸载servlet时执行，把servlet作为服务器进程的一部分关闭。缺省的destroy()方法通常是符合要求的，但也可以override，比如在卸载servlet时将统计数字保存在文件中，或是关闭数据库连接。

getServletConfig()方法返回一个servletConfig对象，该对象用来返回初始化参数和servletContext。servletContext接口提供有关servlet的环境信息。

getServletInfo()方法提供有关servlet的信息，如作者，版本，版权。

### j2ee常用的设计模式？说明工厂模式

Java中的23种设计模式：

Factory（工厂模式）， 

Builder（建造模式），

Factory Method（工厂方法模式），

Prototype（原始模型模式），

Singleton（单例模式）， 

Facade（门面模式），

Adapter（适配器模式）， 

Bridge（桥梁模式）， 

Composite（合成模式），

Decorator（装饰模式）， 

Flyweight（享元模式）， 

Proxy（代理模式），

Command（命令模式）， 

Interpreter（解释器模式）， 

Visitor（访问者模式），

Iterator（迭代子模式）， 

Mediator（调停者模式）， 

Memento（备忘录模式），

Observer（观察者模式）， 

State（状态模式）， 

Strategy（策略模式），

Template Method（模板方法模式）， 

Chain Of Responsibleity（责任链模式）

工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。

### JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗

Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。

用try来指定一块预防所有"异常"的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的"异常"的类型。

throw语句用来明确地抛出一个"异常"。

throws用来标明一个成员函数可能抛出的各种"异常"。

Finally为确保一段代码不管发生什么"异常"都被执行一段代码。

可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，"异常"的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种"异常"进行处理，堆栈就会展开，直到遇到有处理这种"异常"的try语句。

### 排序都有哪几种方法？请列举。口述用JAVA实现快速排序

排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），选择排序（直接选择排序、堆排序）， 归并排序，分配排序（箱排序、基数排序）快速排序的伪代码。

//使用快速排序方法对a[0:n-1]排序

从a[0:n-1]中选择一个元素作为middle，该元素为支点

把余下的元素分割为两段left和right，使得left中的元素都小于等于支点，而right中的元素都大于等于支点

递归地使用快速排序方法对left进行排序

递归地使用快速排序方法对right进行排序

所得结果为left+middle+right

### MVC的各个部分都有那些技术来实现?如何实现

MVC 是Model－View－Controller的简写。

"Model" 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， 

"View" 是应用的表示面，用于与用户的交互（由JSP页面产生），

"Controller" 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。

这些组件可以进行交互和重用。model层实现系统中的业务逻辑，view层用于与用户的交互，controller层是model与view之间沟通的桥梁，可以分派用户的请求并选择恰当的视图以用于显示，同时它也可以解释用户的输入并将它们映射为模型层可执行的操作。

### java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用

有两种实现方法，分别是继承Thread类与实现Runnable接口用synchronized关键字修饰同步方法。

反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状 态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说， 如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

### java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类

字节流，字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。

### java中会存在内存泄漏吗，请简单描述

的确存在Java的内存泄漏， 并且事态可以变得相当严重。

Java garbage collector自动释放哪些内存里面程序不在需要的对象，以此避免大多数的其他程序上下文的内存泄漏。但是Java应用程序依旧会有相当的内存泄漏。查找原因会十分困难。

有两类主要的Java内存泄漏：

非必要的对象引用

Java代码常常保留对于不再需要的对象引用，并且这组织了内存的垃圾收集器的工作。Java对象通常被其他对象包含引用，为此一个单一对象可以保持整个对象树在内存中，于是导致了如下问题: 

- 在向数组添加对象以后遗漏了对于他们的处理

- 直到你再次使用对象的时候都不释放引用。比如一个菜单指令可以插件一个对象实例引用并且不释放便于以后再次调用的时候使用，但是也许永远不会发生。

- 在其他引用依然需要旧有状态的时候贸然修改对象状态。比如当你为了在一个文本文件里面保存一些属性而使用一个数组，诸如"字符个数"等字段在不再需要的时候依然保留在内存当中.

- 允许一个长久执行的线程所引用的对象。设置引用为NULL也无济于事，在线程退出和空闲之前，对象不会被收集释放 

未释放的系统资源

Java方法可以定位Java实例意外的堆内存，诸如针对视窗和位图的内存资源。Java常常通过JNI(Java Native Interface)调用C/C++子程序定位这些资源。

### 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

垃圾回收器可以马上回收内存。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

### 什么是java序列化，如何实现java序列化

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。

序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用 ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

### 内部类可以引用他包含类的成员吗？有没有什么限制

一个内部类对象可以访问创建它的外部类对象的内容。

内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性。

内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性。

一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。

当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。

### 你能说出TCP/IP的7层协议吗

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 

### 在connection类中提供了3个控制事务的方法，分别是

- setAutoCommit(boolean bln) 

  总的来说就是保持数据的完整性，一个系统的更新操作可能要涉及多张表，需多个SQL语句进行操作     循环里连续的进行插入操作，如果在开始时设置了：conn.setAutoCommit(false);   最后才进行conn.commit(),这样即使插入的时候报错，修改的内容也不会提交到数据库，   而如果没有手动的进行setAutoCommit(false);   出错时就会造成，前几条插入，后几条没有插入，会形成脏数据。

- commit()

  提交事务，命令用于把事务所做的修改保存到数据库，它把上一个COMMIT或ROLLBACK命令之后的全部事务都保存到数据库。

- rollback()

  撤销事务，在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已经完成的操作全部撤销，回滚到事务开始时的状态，这里的操作特指数据库更新操作，并且注意回滚后，事务进入提交状态，因为回滚是回滚到事务开始时的状态。

### 简述Statement和PreparedStatement 的区别

无论多少次地使用同一个SQL命令，PreparedStatement都只对它解析和编译一次。当使用Statement对象时，每次执行一个SQL命令时，都会对它进行解析和编译,使用PreparedStatement对象比使用Statement对象的速度更快。

### 简述JAVA中包有什么用途

- 包允许你将类文件组织起来，便于查找和使用合适的类。

- 包不仅包含类和接口，还能包含其它包，从而形成有层次的包空间。

- 包有助于避免命名冲突。当你使用很多类时，确保类和方法名称的唯一性是非常困难的。

- 包能够形成层次命名空间，缩小了名称冲突的范围，易于管理名称。

### 请简述什么是流

流是指一连串流动的字符，是以先进先出的方式发送和接收数据的通道， 流分为输入流和输出流，输入输出流是相对于计算机内存来说的，如果数据输入到内存，则称为输入流，如果从内存中流出则称为输出流

### 请说出java.io.reader和java.io.inputstream的区别

java.io.Reader 和 java.io.InputStream 组成了 Java 输入类。Reader 用于读入16位字符，也就是 Unicode 编码的字符；而 InputStream 用于读入 ASCII 字符和二进制数据。

### 请说出 ArrayList和Vector的区别

主要从二方面来说：

同步性：Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的。

数据增长：当需要增长时,Vector 默认增长为原来一培，而ArrayList却是原来的一半。

### 请说出Java中的异常处理机制的简单原理和应用

当JAVA程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是java.lang.Thowable的子类。

### 请描述继承中的访问权限控制

本类访问权限

本类方法可访问本类所有变量

本类对象不可访问本类private变量

子类访问权限

子类方法不可访问父类private变量

子类对象不可访问父类private变量

父类对象引用可指向它的任何子类对象，不论是直接还是间接子类，反之不行

### 简述Super关键词的好处和使用方法、访问范围

super关键字用来解决如何直接访问或初始化从父类继承来的成员。在写子类无参数构造方法时，不用显式调用父类无参数构造方法，系统会自动提供 ,但在写子类带参数构造方法时，应在第一句写super(参数)来初始化父类成员变量；访问范围包括父类属性、一般方法和构造方法。

### final有哪三种用法？每种用法是什么含义

- 当你在类中定义变量时，在其前面加上final关键字，那便是说，这个变量一旦被初始化便不可改变。

- 将方法声明为final，那就说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。

- 当你将final用于类身上时，你就需要仔细考虑，因为一个final类是无法被任何人继承的，那也就意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。

### 什么是抽象类，抽象类的方法是否可同时是static,是否可同时是native，是否可同时是synchronized

声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。

抽象方法不可被上述三个中的任意一个修饰，抽象方法只能被public或protected修饰，其他修饰符皆不可以。抽象类的一般就是没有什么具体的实现,主要是让子类来帮助他实现。如果在再abstract之前加static,native,synchronized这些修饰符没有任何意义。

### Java中的抽象类有没有对象

抽象类可以声明对象，但是不能使用自身的构造方法创建对象，但是可以使用子类的构造方法进行创建。 

```java
public abstract class A{}     
public class B extends A{}     
A a = new B();    
```

### 请谈谈进程和线程有什么区别

进程一般是对操作系统而言的。例如，你打开word编辑文档，同时打开outlook收取邮件。我们可以说这时系统内有两个进程在运行。即多个程序几乎在同一时间执行多个任务。

线程一般是对某一程序而言的。如上例，你打开outlook收新邮件的同时，还可以看已下载的邮件，这两件事没有相互干扰，那么我们说此时这一程序中至少有两个线程在运行。即每一个程序在同一时间内执行多个任务。

### form中get和post的主要有什么区别

Form中的get和post方法，在数据传输过程中分别对应了HTTP协议中的GET和POST方法。二者主要区别如下：

- Get是用来从服务器上获得数据，而Post是用来向服务器上传递数据。

   Get将表单中数据的按照variable=value的形式，添加到action所指向的URL	后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post是将表单	中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL。

- Get是不安全的，因为在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post的所有操作对用户来说都是不可见的。

- Get传输的数据量小，这主要是因为受URL长度限制；而Post可以传输大量的数据，所以在上传文件只能使用Post（当然还有一个原因，将在后面的提到）。

- Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。

- Get是Form的默认方法。

### 简述MVC的有什么优缺点

优点：

- 开发效率高。

- 松耦合，程序灵活性和扩展性好。

- 代码重用度更高。

- 易于人员分工。

缺点:

- 代码复杂度增加。

- 代码数量增加。

- 不适合开发小型项目。

### 简述MVC三个层次的作用

- 视图(View)

  代表用户交互界面，一个应用可能有很多不同的视图，MVC设计模式对于视图的处理仅限于视图上数据的采集和处理。

- 模型(Model)

  就是业务流程/状态的处理以及业务规则的制定。业务流程的处理过程对其它层来说是黑箱操作，模型接受视图请求的数据，并返回最终的处理结果。业务模型的设计是MVC最主要的核心部分。业务模型包含一个很重要的模型——数据模型。数据模型主要指实体对象的数据保存（持久化），所有有关数据库的操作只限制在该模型中。

- 控制(Controller)

  可以理解为从用户接收请求, 将模型与视图匹配在一起，共同完成用户的请求。控制层并不做任何的数据处理。

### EL表达式的隐含对象及其作用（至少说出4个）

applicationScope

应用程序范围内的scoped变量组成的集合

cookie

所有cookie组成的集合

header

HTTP请求头部，字符串

headerValues

HTTP请求头部，字符串集合

initParam

全部应用程序参数名组成的集合

pageContext

当前页面的javax.servlet.jsp.PageContext对象

pageScope

页面范围内所有对象的集合

param

所有请求参数字符串组成的集合

paramValues

所有作为字符串集合的请求参数

requestScope

所有请求范围的对象的集合

sessionScope

所有会话范围的对象的集合 

### HashMap源码实现原理及底层结构

HashMap和Hashtable两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全，HashMap可以使用null作为key，而Hashtable则不允许null作为key，HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类。

**HashMap和Hashtable的区别**

1）两者最主要的区别在于**Hashtable**是线程安全，而**HashMap**则非线程安全

**Hashtable**的实现方法里面都添加了**synchronized**关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用**HashMap**需要使用**Collections.synchronizedMap()**方法来获取一个线程安全的集合（**Collections.synchronizedMap()**实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是**Collections.synchronizedMap()**方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它**Collections.synchronizedXX**方法也是类似原理）

2）HashMap可以使用null作为key，而**Hashtable**则不允许null作为key

虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事

HashMap以null作为key时，总是存储在table数组的第一个节点上

3）HashMap是对Map接口的实现，**Hashtable**实现了Map接口和Dictionary抽象类

4）HashMap的初始容量为16，**Hashtable**初始容量为11，两者的填充因子默认都是0.75

HashMap扩容时是当前容量翻倍即:capacity*2，**Hashtable**扩容时是容量翻倍+1即:capacity*2+1

5）两者计算hash的方法不同

**Hashtable**计算hash是直接使用key的**hashcode**对table数组的长度直接进行取模

> int hash = key.hashCode();
>
> int index = (hash & 0x7FFFFFFF) % tab.length;

HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸

> static int hash(int h) {
>
> 	// This function ensures that hashCodes that differ only by
> 	
> 	// constant multiples at each bit position have a bounded
> 	
> 	// number of collisions (approximately 8 at default load factor).
> 	
> 	h ^= (h >>> 20) ^ (h >>> 12);
> 	
> 	return h ^ (h >>> 7) ^ (h >>> 4);
>
> }
>
> static int indexFor(int h, int length) {
>
> 	return h & (length-1);
>
> }

**HashMap**和**Hashtable**的底层实现都是数组+链表结构实现

**HashSet和HashMap、Hashtable的区别**

除开HashMap和**Hashtable**外，还有一个hash集合HashSet，有所区别的是**HashSet**不是key value结构，仅仅是存储不重复的元素，相当于简化版的**HashMap**，只是包含**HashMap**中的key而已。

通过查看源码也证实了这一点，**HashSet**内部就是使用HashMap实现，只不过HashSet里面的**HashMap**所有的value都是同一个Object而已，因此HashSet也是非线程安全的，至于HashSet和**Hashtable**的区别，HashSet就是个简化的HashMap的，所以你懂的。

下面是HashSet几个主要方法的实现

> private transient HashMap<E,Object> map;
>
> private static final Object PRESENT = new Object();
>
> 
>
> public HashSet() {
>
>     map = new HashMap<E,Object>();
>
> }
>
> public boolean contains(Object o) {
>
>     return map.containsKey(o);
>
> }
>
> public boolean add(E e) {
>
>     return map.put(e, PRESENT)==null;
>
> }
>
> public boolean add(E e) {
>
>     return map.put(e, PRESENT)==null;
>
> }
>
> public boolean remove(Object o) {
>
>     return map.remove(o)==PRESENT;
>
> }
>
> public void clear() {
>
>     map.clear();
>
> }

**HashMap和Hashtable的实现原理**

HashMap和**Hashtable**的底层实现都是数组+链表结构实现的，这点上完全一致。

添加、删除、获取元素时都是先计算hash，根据hash和**table.length**计算index也就是table数组的下标，然后进行相应操作，下面以HashMap为例说明下它的简单实现

> /**
>
>  \* HashMap的默认初始容量 必须为2的n次幂
>
>  */
>
> static final int DEFAULT_INITIAL_CAPACITY = 16;
>
> /**
>
>  \* HashMap的最大容量，可以认为是int的最大值    
>
>  */
>
> static final int MAXIMUM_CAPACITY = 1 << 30;
>
> /**
>
>  \* 默认的加载因子
>
>  */
>
> static final float DEFAULT_LOAD_FACTOR = 0.75f;
>
> /**
>
>  \* HashMap用来存储数据的数组
>
>  */
>
> transient Entry[] table;
>
> HashMap的创建
>
> HashMap默认初始化时会创建一个默认容量为16的Entry数组，默认加载因子为0.75，同时设置临界值为16*0.75
>
> /**
>
>  \* Constructs an empty <tt>HashMap</tt> with the default initial capacity
>
>  \* (16) and the default load factor (0.75).
>
>  */
>
> public HashMap() {
>
> 	this.loadFactor = DEFAULT_LOAD_FACTOR;
> 	
> 	threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
> 	
> 	table = new Entry[DEFAULT_INITIAL_CAPACITY];
> 	
> 	init();
>
> }

**put方法**

HashMap会对null值key进行特殊处理，总是放到**table[0]**位置

put过程是先计算hash然后通过hash与**table.length**取摸计算index值，然后将key放到**table[index]**位置，当table[index]已存在其它元素时，会在**table[index]**位置形成一个链表，将新添加的元素放在**table[index]**，原来的元素通过Entry的next进行链接，这样以链表形式解决hash冲突问题，当元素数量达到临界值**(capactiy\*factor)**时，则进行扩容，是table数组长度变为**table.length\*2**

> public V put(K key, V value) {
>
> 	if (key == null)
> 	
> 		return putForNullKey(value); //处理null值
> 	
> 	int hash = hash(key.hashCode());//计算hash
> 	
> 	int i = indexFor(hash, table.length);//计算在数组中的存储位置
>
> //遍历table[i]位置的链表，查找相同的key，若找到则使用新的value替换掉原来的oldValue并返回oldValue
>
> 	for (Entry<K,V> e = table[i]; e != null; e = e.next) {
> 	
> 		Object k;
> 	
> 		if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
> 	
> 			V oldValue = e.value;
> 	
> 			e.value = value;
> 	
> 			e.recordAccess(this);
> 	
> 			return oldValue;
> 	
> 		}
> 	
> 	}
>
> //若没有在table[i]位置找到相同的key，则添加key到table[i]位置，新的元素总是在table[i]位置的第一个元素，原来的元素后移
>
> 	modCount++;
> 	
> 	addEntry(hash, key, value, i);
> 	
> 	return null;
>
> }
>
> void addEntry(int hash, K key, V value, int bucketIndex) {
>
> //添加key到table[bucketIndex]位置，新的元素总是在table[bucketIndex]的第一个元素，原来的元素后移
>
> Entry<K,V> e = table[bucketIndex];
>
> 	table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
>
> //判断元素个数是否达到了临界值，若已达到临界值则扩容，table长度翻倍
>
> 	if (size++ >= threshold)
> 	
> 		resize(2 * table.length);
>
> }



**get方法**

同样当key为null时会进行特殊处理，在table[0]的链表上查找key为null的元素

get的过程是先计算hash然后通过hash与**table.length**取摸计算index值，然后遍历**table[index]**上的链表，直到找到key，然后返回

> public V get(Object key) {
>
> 	if (key == null)
> 	
> 		return getForNullKey();//处理null值
> 	
> 	int hash = hash(key.hashCode());//计算hash
>
> //在table[index]遍历查找key，若找到则返回value，找不到返回null
>
> 	for (Entry<K,V> e = table[indexFor(hash, table.length)];
> 	
> 		 e != null;
> 	
> 		 e = e.next) {
> 	
> 		Object k;
> 	
> 		if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
> 	
> 			return e.value;
> 	
> 	}
> 	
> 	return null;
>
> }

**remove方法**

remove方法和put get类似，计算hash，计算index，然后遍历查找，将找到的元素从**table[index]**链表移除

> public V remove(Object key) {
>
> 	Entry<K,V> e = removeEntryForKey(key);
> 	
> 	return (e == null ? null : e.value);
>
> }
>
> final Entry<K,V> removeEntryForKey(Object key) {
>
> 	int hash = (key == null) ? 0 : hash(key.hashCode());
> 	
> 	int i = indexFor(hash, table.length);
> 	
> 	Entry<K,V> prev = table[i];
> 	
> 	Entry<K,V> e = prev;
>
> 
>
> 	while (e != null) {
> 	
> 		Entry<K,V> next = e.next;
> 	
> 		Object k;
> 	
> 		if (e.hash == hash &&
> 	
> 			((k = e.key) == key || (key != null && key.equals(k)))) {
> 	
> 			modCount++;
> 	
> 			size--;
> 	
> 			if (prev == e)
> 	
> 				table[i] = next;
> 	
> 			else
> 	
> 				prev.next = next;
> 	
> 			e.recordRemoval(this);
> 	
> 			return e;
> 	
> 		}
> 	
> 		prev = e;
> 	
> 		e = next;
> 	
> 	}
>
> 
>
> 	return e;
>
> }

**resize方法**

**resize**方法在**hashmap**中并没有公开，这个方法实现了非常重要的hashmap扩容，具体过程为：先创建一个容量为**table.length\*2**的新table，修改临界值，然后把table里面元素计算hash值并使用hash与**table.length\*2**重新计算index放入到新的table里面。

这里需要注意下是用每个元素的hash全部重新计算index，而不是简单的把原table对应index位置元素简单的移动到新table对应位置

> void resize(int newCapacity) {
>
> 	Entry[] oldTable = table;
> 	
> 	int oldCapacity = oldTable.length;
> 	
> 	if (oldCapacity == MAXIMUM_CAPACITY) {
> 	
> 		threshold = Integer.MAX_VALUE;
> 	
> 		return;
> 	
> 	}
> 	
> 	Entry[] newTable = new Entry[newCapacity];
> 	
> 	transfer(newTable);
> 	
> 	table = newTable;
> 	
> 	threshold = (int)(newCapacity * loadFactor);
>
> }
>
> void transfer(Entry[] newTable) {
>
> 	Entry[] src = table;
> 	
> 	int newCapacity = newTable.length;
> 	
> 	for (int j = 0; j < src.length; j++) {
> 	
> 		Entry<K,V> e = src[j];
> 	
> 		if (e != null) {
> 	
> 			src[j] = null;        
> 	
> 			do {
> 	
> 				Entry<K,V> next = e.next;
> 	
> 				//重新对每个元素计算index
> 	
> 				int i = indexFor(e.hash, newCapacity);
> 	
> 				e.next = newTable[i];
> 	
> 				newTable[i] = e;
> 	
> 				e = next;
> 	
> 			} while (e != null);
> 	
> 		}
> 	
> 	}
>
> }

**clear()方法**

**clear**方法非常简单，就是遍历**table**然后把每个位置置为null，同时修改元素个数为0，需要注意的是**clear**方法只会清楚里面的元素，并不会重置capactiy。

> public void clear() {
>
> 	modCount++;
> 	
> 	Entry[] tab = table;
> 	
> 	for (int i = 0; i < tab.length; i++)
> 	
> 		tab[i] = null;
> 	
> 	size = 0;
>
> }

**containsKey和containsValue**

**containsKey**方法是先计算hash然后使用hash和**table.length**取摸得到index值，遍历**table[index]**元素查找是否包含key相同的值

> public boolean containsKey(Object key) {
>
>         return getEntry(key) != null;
>     
>     }
>
> final Entry<K,V> getEntry(Object key) {
>
> 	int hash = (key == null) ? 0 : hash(key.hashCode());
> 	
> 	for (Entry<K,V> e = table[indexFor(hash, table.length)];
> 	
> 		 e != null;
> 	
> 		 e = e.next) {
> 	
> 		Object k;
> 	
> 		if (e.hash == hash &&
> 	
> 			((k = e.key) == key || (key != null && key.equals(k))))
> 	
> 			return e;
> 	
> 	}
> 	
> 	return null;
>
> }

**containsValue**方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见**HashMap**的**containsValue**方法本质上和普通数组和list的**contains**方法没什么区别，你别指望它会像**containsKey**那么高效

> public boolean containsValue(Object value) {
>
> 	if (value == null)
> 	
> 			return containsNullValue();
> 	
> 	Entry[] tab = table;
> 	
> 		for (int i = 0; i < tab.length ; i++)
> 	
> 			for (Entry e = tab[i] ; e != null ; e = e.next)
> 	
> 				if (value.equals(e.value))
> 	
> 					return true;
> 	
> 	return false;
>
> }



**hash和indexFor**

**indexFor**中的**h & (length-1)**就相当于**h%length**，用于计算index也就是在table数组中的下标

hash方法是对hashcode进行二次散列，以获得更好的散列值

为了更好理解这里我们可以把这两个方法简化为 **int index= key.hashCode()/table.length**,以put中的方法为例可以这样替换

**int hash = hash(key.hashCode());**//计算hash

**int i = indexFor(hash, table.length);**//计算在数组中的存储位置

//上面这两行可以这样简化

**int i = key.key.hashCode()%table.length;**

>  static int hash(int h) {
>
>  	// This function ensures that hashCodes that differ only by
>  	
>  	// constant multiples at each bit position have a bounded
>  	
>  	// number of collisions (approximately 8 at default load factor).
>  	
>  	h ^= (h >>> 20) ^ (h >>> 12);
>  	
>  	return h ^ (h >>> 7) ^ (h >>> 4);
>
>  }
>
>  static int indexFor(int h, int length) {
>
>  	return h & (length-1);
>
>  }

### Java面试高级篇—Java中的队列都有哪些，有什么区别

阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。

试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。

同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列。

1）**ArrayDeque**, （数组双端队列） 

2）**PriorityQueue**, （优先级队列） 

3）**ConcurrentLinkedQueue**, （基于链表的并发队列） 

4）**DelayQueue**, （延期阻塞队列）（阻塞队列实现了**BlockingQueue**接口） 

5）**ArrayBlockingQueue**, （基于数组的并发阻塞队列） 

6）**LinkedBlockingQueue**, （基于链表的**FIFO**阻塞队列） 

7）**LinkedBlockingDeque**, （基于链表的**FIFO**双端阻塞队列） 

8）**PriorityBlockingQueue**, （带优先级的无界阻塞队列） 

9）**SynchronousQueue**, （并发同步阻塞队列）

**阻塞队列和生产者-消费者模式**

阻塞队列（**Blocking queue**）提供了可阻塞的put和take方法，它们与可定时的offer和poll是等价的。如果Queue已经满了，put方法会被阻塞直到有空间可用；如果**Queue**是空的，那么take方法会被阻塞，直到有元素可用。**Queue**的长度可以有限，也可以无限；无限的**Queue**永远不会充满，所以它的put方法永远不会阻塞。

阻塞队列支持生产者-消费者设计模式。一个生产者-消费者设计分离了“生产产品”和“消费产品”。该模式不会发现一个工作便立即处理，而是把工作置于一个任务（“**to do**”）清单中，以备后期处理。

生产者-消费者模式简化了开发，因为它解除了生产者和消费者之间相互依赖的代码。生产者和消费者以不同的或者变化的速度生产和消费数据，生产者-消费者模式将这些活动解耦，因而简化了工作负荷的管理。

生产者-消费者设计是围绕阻塞队列展开的，生产者把数据放入队列，并使数据可用，当消费者为适当的行为做准备时会从队列中获取数据。

生产者不需要知道消费者的省份或者数量，甚至根本没有消费者—它们只负责把数据放入队列。类似地，消费者也不需要知道生产者是谁，以及是谁给它们安排的工作。

**BlockingQueue**可以使用任意数量的生产者和消费者，从而简化了生产者-消费者设计的实现。最常见的生产者-消费者设计是将线程池与工作队列相结合。

阻塞队列简化了消费者的编码，因为**take**会保持阻塞直到可用数据出现。如果生产者不能足够快地产生工作，让消费者忙碌起来，那么消费者只能一直等待，直到有工作可做。

同时，**put**方法的阻塞特性也大大地简化了生产者的编码；如果使用一个有界队列，那么当队列充满的时候，生产者就会阻塞，暂不能生成更多的工作，从而给消费者时间来赶进进度。

有界队列是强大的资源管理工具，用来建立可靠的应用程序：它们遏制那些可以产生过多工作量、具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮。

虽然生产者-消费者模式可以把生产者和消费者的代码相互解耦合，但是它们的行为还是间接地通过共享队列耦合在一起了。

类库中包含一些**BlockingQueue**的实现，其中**LinkedBlockingQueue**和**ArrayBlockingQueue**是FIFO队列，与 LinkedList和ArrayList相似，但是却拥有比同步List更好的并发性能。

**PriorityBlockingQueue**是一个按优先级顺序排序的队列，当你不希望按照FIFO的属性处理元素时，这个**PriorityBolckingQueue**是非常有用的。

正如其他排序的容器一样，**PriorityBlockingQueue**可以比较元素本身的自然顺序（如果它们实现了**Comparable**），也可以使用一个 **Comparator**进行排序。

最后一个**BlockingQueue**的实现是SynchronousQueue，它根本上不是一个真正的队列，因为它不会为队列元素维护任何存储空间。不过，它维护一个排队的线程清单，这些线程等待把元素加入（enqueue）队列或者移出（dequeue）队列。

因为**SynchronousQueue**没有存储能力，所以除非另一个线程已经准备好参与移交工作，否则put和take会一直阻止。**SynchronousQueue**这类队列只有在消费者充足的时候比较合适，它们总能为下一个任务作好准备。

**非阻塞算法**

基于锁的算法会带来一些活跃度失败的风险。如果线程在持有锁的时候因为阻塞I/O，页面错误，或其他原因发生延迟，很可能所有的线程都不能前进了。 

一个线程的失败或挂起不应该影响其他线程的失败或挂起，这样的算法成为非阻塞（**nonblocking**）算法；如果算法的每一个步骤中都有一些线程能够继续执行，那么这样的算法称为锁自由（**lock-free**）算法。在线程间使用CAS进行协调，这样的算法如果能构建正确的话，它既是非阻塞的，又是锁自由的。

非竞争的CAS总是能够成功，如果多个线程以一个CAS竞争，总会有一个胜出并前进。非阻塞算法堆死锁和优先级倒置有“免疫性”（但它们可能会出现饥饿和活锁，因为它们允许重进入）。

非阻塞算法通过使用低层次的并发原语，比如比较交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当做“更佳的**volatile**变量”使用，同时提供了整数类和对象引用的原子化更新操作。

### Session和Cookie的区别与联系

**Session的概念**

Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个**Session ID**用来唯一标识这个Session，并将其通过响应发送到浏览器。

当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出**Session ID**，并和保存的所有Session ID进行对比，找到这个用户对应的Session。

一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现：

1）使用**Cookie**来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将**Session ID**发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，**Cookie**就消失了，这个**Session ID**就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。

2）使用URL附加信息的方式，也就是像我们经常看到JSP网站会有**aaa.jsp?JSESSIONID=\***一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。

3）第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。

**会话（Session）跟踪**

会话，指用户登录网站后的一系列动作，比如浏览商品添加到购物车并购买。会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是**Cookie**与**Session**。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。

**Cookie和Session区别**

cookie存储在客户端（浏览器），session存储在服务端，简 单的说，当你登录一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前**sessionid**判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。

由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的**sessionid**，用特殊的浏览器伪造该用户的请求也是能够成功的。**sessionid**是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。

**Session与Cookie联系**

Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“**Session**”则会占用服务器资源。所以，尽量不要使用**Session**，而使用Cookies。

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibxhfFaYCuYwmxbhTGXUF8uKEdnzLfWTIiaFSJXMsu1AfIVibXGqN0icvyJxFoic1ZoonZSZB2PnoDcOVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。

**Cookies与Session的应用场景**

**Cookies**的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以**Cookies**到底该不该用，到底该怎样用，就有了一个需要给定的底线。![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibxhfFaYCuYwmxbhTGXUF8uKbzaYkhz8ibw44nvqxX3Mz3KMicZDRvu66kpkbkGW0a2Wh6TgFFVfjVSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**1）session**

登陆验证信息。一般采用**Session(“Logon”)＝true or false**的形式。 用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里 需要在页面间传递 的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更 新到数据库。

**2）cookie**

判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登 录必须从新填写登录的相关信息。 另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同 页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信 息，当然这里面有了安全和性能问题需要我们考虑了。

**session共享**

对于多网站(同一父域不同子域)单服务器，我们需要解决的就是来自不同网站之间SessionId的共享。由于域名不同（**blog.yoodb.com** 和**daohang.yoodb.com**），而SessionId又分别储存在各自的cookie中，因此服务器会认为对于两个子站的访问,是来自不同的会话。

解决的方法是通过修改cookies的域名为父域名达到**cookie**共享的目的,从而实现SessionId的共享。带来的弊端就是，子站间的cookie信息也同时被共享了。

**cookie典型应用**

1）判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。

2）在线商城“购物车”中处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面需要考虑安全和性能问题。

**总结**

1）**cookie**数据存放在客户的浏览器上，session数据放在服务器上。

2）**cookie**不是很安全，别人可以分析存放在本地的**cookie**并进行cookie欺骗，考虑到安全应当使用session。

3）**session**会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。

4）单个**cookie**保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个**cookie**。

5）可以考虑将登陆信息等重要信息存放为**session**，其他信息如果需要保留，可以放在**cookie**中。

### 说说TCP,UDP和socket,Http之间联系和区别

**TCP协议**

TCP（**Transmission Control Protocol** 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的**RFC 793**定义。在简化的计算机网络**OSI**模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。

在因特网协议族（**Internet protocol suite**）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibz91bWTZc1l0UxvsY5Lje6ic7B8lKM0Hf9WMM9PpHESw5ycFBX0zDyeania5ZyDH5CMWHtiaqAALIiaOw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**TCP的优点**

可靠，稳定

**TCP**的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

**TCP的缺点**

慢，效率低，占用系统资源高，易被攻击

**TCP**在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的**CPU**、内存等硬件资源。 

由于TCP存在确认机制和三次握手机制，这些是导致**TCP**容易被人利用，实现**DOS、DDOS、CC**等攻击。

**TCP应用场景**

当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如**HTTP**、**HTTPS**、**FTP**等传输文件的协议，**POP**、**SMTP**等邮件传输的协议。 

在日常生活中，常见使用TCP协议的应用比如：浏览器使用HTTP，Outlook使用**POP**、**SMTP**，**QQ**文件传输等。

**UDP协议**

UDP 是**User Datagram Protocol**的简称， 中文名是用户数据报协议，是OSI（**Open System Interconnection**，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。

**UDP的优点**

快，比TCP稍安全 

UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：**UDP Flood**攻击……

**UDP的缺点**

不可靠，不稳定 

因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

**UDP应用场景**

当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。在日常生活中，常见使用UDP协议的应用比如：QQ语音、QQ视频、TFTP等。

**TCP**和**UDP**使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。**TCP**和**UDP**是高速公路上的“卡车”，它们携带的货物就是像**HTTP**，文件传输协议FTP这样的协议等。

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibz91bWTZc1l0UxvsY5Lje6icTE67PvW7HnnoMoib02YDibuWibVXUMXaE7Cw3NDV2SCRg8YicVNjhpRGkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

TCP/IP是个协议组，可分为三个层次：**网络层、传输层和应用层**。

在网络层有：IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 

在传输层中有：**TCP**协议与**UDP**协议。 

在应用层有：**FTP、HTTP、TELNET、SMTP、DNS**等协议。 

因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。

TCP和UDP是**FTP，HTTP**和SMTP之类使用的传输层协议。虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibz91bWTZc1l0UxvsY5Lje6icA8licJbxevxpLWkaagkZZ0DEVa4DknictQW5A7bNY9Kw0icwbmb0iaKXyw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**HTTP协议**

**HTTP**（超文本传输协议）是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibz91bWTZc1l0UxvsY5Lje6icPziaibibia6CGDIxzI5oBh0R38LsVbpmpichjdrrbFBUlS8hRibyia7OpDMKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**HTTP**是短连接：客户端发送请求都需要服务器端回送响应.请求结束后，主动释放链接，因此为短连接。通常的做法是，不需要任何数据，也要保持每隔一段时间向服务器发送"保持连接"的请求。这样可以保证客户端在服务器端是"上线"状态。

**HTTP**连接使用的是"请求-响应"方式，不仅在请求时建立连接，而且客户端向服务器端请求后，服务器才返回数据。

**Socket协议**

网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个**socket**。

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibz91bWTZc1l0UxvsY5Lje6icnQytgaKYLT8N4JQDunRgej2UKAErGWYeS3pWDw5MIZdpcoILrJscUw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

建立网络通信连接至少要一对端口号（**socket**）。**socket**本质是编程接口（**API**），对**TCP/IP**的封装，**TCP/IP**也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；**Socket**是发动机，提供了网络通信的能力。

### 详谈Java四种线程池及new Thread的弊端

**new Thread 的弊端**

执行异步任务只是如下 **new Thread()** 吗？

> new Thread(new Runnable() {
>
>     @Override
>     
>     public void run() {
>     
>         // TODO Auto-generated method stub
>     
>     }
>
> }).start();

那你就太out了，new Thread的弊端如下：

1）每次通过**new Thread()**创建对象性能不佳。

2）线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。

3）缺乏更多功能，如定时执行、定期执行、线程中断。

相比**new Thread**，**Java**提供的四种线程池的好处在于： 

1）重用存在的线程，减少对象创建、消亡的开销，提升性能。

2）可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。

3）提供定时执行、定期执行、单线程、并发数控制等功能。

**Java 线程池**

**Java**通过**Executors**提供四种线程池，分别为： 

**newCachedThreadPool**创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 

**newFixedThreadPool** 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 

**newScheduledThreadPool** 创建一个定长线程池，支持定时及周期性任务执行。 

**newSingleThreadExecutor** 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(**FIFO**, **LIFO**, 优先级)执行。

**Java**里面线程池的顶级接口是**Executor**，但是严格意义上讲**Executor**并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是**ExecutorService**。下面这张图完整描述了线程池的类体系结构：

![1521556140357051038.png](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibwf26UBLtaLujVoHuicM5ZicDylozY1EwaVZDVmS50eO7YoLl7cJlcxpEbQibNleKMMicWuQdgCYVOFjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**1. newCachedThreadPool**

创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 **execute** 将重用以前构造的线程（如果线程可用）。

如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。

> public static ExecutorService newCachedThreadPool()

示例代码：

> public class ThreadPoolExecutorTest {
>
>    public static void main(String[] args ) {
>
>     ExecutorService cacheThreadPool =Executors.newCachedThreadPool();
>     
>      for(int i =1;i<=5;i++){
>     
>        final int index=i ;
>     
>        try{
>     
>         Thread.sleep(1000);
>     
>       }catch(InterruptedException e ) {
>     
>          e.printStackTrace();
>     
>       }
>     
>        cacheThreadPool.execute(new Runnable(){
>     
>          @Override
>     
>          public void run() {
>     
>           System.out.println("第" +index +"个线程" +Thread.currentThread().getName());  
>     
>         }  
>     
>       });
>     
>     }
>
>   }
>
> }

//输出结果

第1个线程pool-1-thread-1

第2个线程pool-1-thread-1

第3个线程pool-1-thread-1

第4个线程pool-1-thread-1 第5个线程pool-1-thread-1  

由结果可看出 当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。

**2. newFixedThreadPool**

创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。

> public static ExecutorService newFixedThreadPool(int nThreads)

**nThreads - 池中的线程数**

示例代码：

> public class ThreadPoolExecutorTest {
>
>    public static void main(String[] args) {
>
>     ExecutorService fixedThreadPool =Executors. newFixedThreadPool(3);
>     
>      for (int i =1; i<=5;i++){
>     
>        final int index=i ;
>     
>        fixedThreadPool.execute(new Runnable(){
>     
>          @Override
>     
>          public void run() {
>     
>            try {
>     
>             System.out.println("第" +index + "个线程" +Thread.currentThread().getName());
>     
>             Thread.sleep(1000);
>     
>           } catch(InterruptedException e ) {
>     
>              e .printStackTrace();
>     
>           }
>     
>         }
>     
>       });
>     
>     }
>
>   }
>
> }

由于设置最大线程数为3，所以在输出三个数后等待2秒后才继续输出。

**2. newScheduledThreadPool**

创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

> public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)

corePoolSize - 池中所保存的线程数，即使线程是空闲的也包括在内。

延迟执行示例代码：

> public class ThreadPoolExecutorTest {  
>
>   public static void main(String[] args) {
>
>     ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);   
>     
>     scheduledThreadPool.schedule(newRunnable(){     
>     
>       @Override
>     
>       public void run() {
>     
>        System.out.println("延迟三秒");
>     
>        }
>
>    }, 3, TimeUnit.SECONDS);
>
>   }
>
> }

表示延迟3秒执行。

定期执行示例代码：

> public class ThreadPoolExecutorTest {  
>
>   public static void main(String[] args) {
>
>  
>
>     ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);    
>
>   scheduledThreadPool.scheduleAtFixedRate(newRunnable(){    
>
>     @Override      
>     
>     public void run() {
>     
>        System.out.println("延迟1秒后每三秒执行一次");
>     
>      }
>
>    },1,3,TimeUnit.SECONDS);
>
>  }
>
> }

表示延迟1秒后每3秒执行一次。

**4.newSingleThreadExecutor**

创建一个使用单个 worker 线程的 **Executor**，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 **newFixedThreadPool(1)**不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。

> public static ExecutorService newSingleThreadExecutor()

示例代码：

> public class ThreadPoolExecutorTest {  
>
>   public static void main(String[] args) {
>
>     ExecutorService singleThreadPool= Executors.newSingleThreadExecutor();    
>     
>     for(int i=1;i<=5;i++){      
>     
>       int index=i;      
>     
>     singleThreadPool.execute(new Runnable(){
>     
>        @Override
>     
>        public void run() {         
>     
>         try{
>     
>          System.out.println("第"+index+"个线程");
>     
>         Thread.sleep(2000);
>     
>          }catch(InterruptedException e) {            
>     
>           e.printStackTrace();
>     
>         }
>     
>       } });
>     
>     }
>
>   }
>
> }

### Java NIO：浅析I/O模型

在进入**Java NIO**编程之前，我们今天先来讨论一些比较基础的知识：I/O模型。本文先从同步和异步的概念 说起，然后接着阐述了阻塞和非阻塞的区别，接着介绍了阻塞IO和非阻塞IO的区别，然后介绍了同步IO和异步IO的区别，接下来介绍了5种IO模型，最后介绍了两种和高性能IO设计相关的设计模式（**Reactor**和**Proactor**）。

以下是本文的目录大纲：

一.什么是同步？什么是异步？

二.什么是阻塞？什么是非阻塞？

三.什么是阻塞IO？什么是非阻塞IO？

四.什么是同步IO？什么是异步IO？

五.五种IO模型

六.两种高性能IO设计模式

若有不正之处，请多多谅解并欢迎批评指正。

**一. 什么是同步？什么是异步？**

同步和异步的概念出来已经很久了，网上有关同步和异步的说法也有很多。以下是我个人的理解：

同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；

异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。

这就是同步和异步。举个简单的例子，假如有一个任务包括两个子任务A和B，对于同步来说，当A在执行的过程中，B只有等待，直至A执行完毕，B才能执行；而对于异步就是A和B可以并发地执行，B不必等待A执行完毕之后再执行，这样就不会由于A的执行导致整个任务的暂时等待。



如果还不理解，可以先看下面这2段代码：

> void fun1() {
>
> }
>
> void fun2() {
>
> }
>
> void function(){
>
> fun1();
>
> fun2()
>
> .....
>
> .....
>
> }

这段代码就是典型的同步，在方法function中，fun1在执行的过程中会导致后续的fun2无法执行，fun2必须等待fun1执行完毕才可以执行。

接着看下面这段代码：

> void fun1() {
>
> }
>
> 
>
> void fun2() {
>
> }
>
> 
>
> void function(){
>
>     new Thread(){
>     
>     public void run() {
>     
>         fun1();
>     
>     }
>
> }.start();
>
> 
>
> new Thread(){
>
>     public void run() {
>     
>         fun2();
>     
>     }
>
> }.start();
>
> .....
>
> .....
>
> }

这段代码是一种典型的异步，fun1的执行不会影响到fun2的执行，并且fun1和fun2的执行不会导致其后续的执行过程处于暂时的等待。

事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。我觉得可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。

因此，个人觉得同步和异步可以表现在很多方面，但是记住其关键在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。一般来说，可以通过多线程的方式来实现异步，但是千万记住不要将多线程和异步画上等号，异步只是宏观上的一个模式，采用多线程来实现异步只是一种手段，并且通过多进程的方式也可以实现异步。

**二.什么是阻塞？什么是非阻塞？**

在前面介绍了同步和异步的区别，这一节来看一下阻塞和非阻塞的区别。

阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；

非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。

这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。

举个简单的例子：

假如我要读取一个文件中的内容，如果此时文件中没有内容可读，对于同步来说就是会一直在那等待，直至文件中有内容可读；而对于非阻塞来说，就会直接返回一个标志信息告知文件中暂时无内容可读。

在网上有一些朋友将同步和异步分别与阻塞和非阻塞画上等号，事实上，它们是两组完全不同的概念。注意，理解这两组概念的区别对于后面IO模型的理解非常重要。

同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；

而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。

理解阻塞和非阻塞可以同线程阻塞类比地理解，当一个线程进行一个请求操作时，如果条件不满足，则会被阻塞，即在那等待条件满足。

**三.什么是阻塞IO？什么是非阻塞IO？**

在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。

通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。

当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：

1）查看数据是否就绪；

2）进行数据拷贝（内核将数据拷贝到用户线程）。

那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。

Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。

**四.什么是同步IO？什么是异步IO？**

我们先来看一下同步IO和异步IO的定义，在《Unix网络编程》一书中对同步IO和异步IO的定义是这样的：

A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.

An asynchronous I/O operation does not cause the requesting process to be blocked.

从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。

事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：

对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；

而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。

这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。

注意同步IO和异步IO与阻塞IO和非阻塞IO是不同的两组概念。

阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。

**五.五种IO模型**

在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。

下面就分别来介绍一下这5种IO模型的异同。

**1.阻塞IO模型**

最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。

当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。

典型的阻塞IO模型的例子为：

> data = socket.read();

如果数据没有就绪，就会一直阻塞在read方法。

**2.非阻塞IO模型**

当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。

所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

典型的非阻塞IO模型一般如下：

> while(true){
>
>     data = socket.read();
>     
>     if(data!= error){
>     
>         处理数据
>     
>         break;
>     
>     }
>
> }

但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。

**3.多路复用IO模型**

多路用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。

在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

在**Java NIO**中，是通过**selector.select()**去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。

也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。

而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。

另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。

不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。

**4.信号驱动IO模型**

在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

**5.异步IO模型**

异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个**asynchronous read**之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。

也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。

注意，*异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。*

前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。

**六.两种高性能IO设计模式**

在传统的网络服务设计模式中，有两种比较经典的模式：一种是 多线程，一种是线程池。

对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibxlSzkicbWic3bPXsqDf3DPj4AMZw9TX40nESC8MP3sQsl6kQ9X9G9RvGECuibrCDhkiaSDcYeYtXLh8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。

因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。

但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。

因此便出现了下面的两种高性能IO设计模式：**Reactor**和**Proactor**。

在**Reactor**模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：

![img](https://mmbiz.qpic.cn/mmbiz_png/tJdrRlG3mibxlSzkicbWic3bPXsqDf3DPj4Fab96gkPVT45F0FrpWzDFbsUAKPI8UgTXHibtRrKsFD0mmDQ5Pjmwyg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。

在**Proactor**模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是**Proactor**模式。

### 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。  Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

### JDK、JRE、JVM关系是什么

- JDK（Java Development Kit）

  即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。开发工具如：用于编译java程序的javac命令、用于启动JVM运行java程序的java命令、用于生成文档的javadoc命令以及用于打包的jar命令等等。 

- JRE（Java Runtime Environment）

  即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。 

- JVM（Java Virtual Machines）

  即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。 
  简单说，就是JDK包含JRE包含JVM。

### Java支持的数据类型有哪些？什么是自动拆装箱

基本数据类型： 
整数值型：byte,short,int,long, 
字符型：char 
浮点类型：float,double 
布尔型：boolean 
整数默认int型，小数默认是double型。Float和long类型的必须加后缀。

首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。 
而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。

### 什么是值传递和引用传递

值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 一般认为,java内的传递都是值传递. java中实例对象的传递是引用传递 。

### 是否可以在static环境中访问非static变量

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

### Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思

Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。

### Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法

当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。 
Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。 
Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。

### Java支持多继承么

Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。

### 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

### Java集合框架是什么？说出一些集合框架的优点

每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下： 
（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。 
（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。 
（3）通过使用JDK附带的集合类，可以降低代码维护成本。 
（4）复用性和可操作性。

### 集合框架中的泛型有什么优点

Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。

### Java集合框架的基础接口有哪些

Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。## 标题 ## 
Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。 
List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。 
Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。 
一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。

### 为何Collection不从Cloneable和Serializable接口继承

Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。 
当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。 
在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。

### 为何Map接口不继承Collection接口

尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。 
如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。

### 什么是迭代器(Iterator)

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。

### Iterator和ListIterator的区别是什么

下面列出了他们的区别： 
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

### 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么

快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。 
在java.util包下的都是快速失败。 
安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。 
在java.util.concurrent包下的全是安全失败的。

### Java中的HashMap的工作原理是什么

我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：最左侧是一个数组，数组中的每一个元素都是一个链表，链表的每一个元素都是entry。

HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。

### 当两个对象的hashcode相同会发生什么

因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。

### 如果两个键的hashcode相同，你如何获取值对象

当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。

### hashCode()和equals()方法有何重要性

HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则： 
（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。 
（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。 

### HashMap和Hashtable有什么区别

1、HashMap是非线程安全的，HashTable是线程安全的。 
2、HashMap的键和值都允许有null值存在，而HashTable则不行。 
3、因为线程安全的问题，HashMap效率比HashTable的要高。 
4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 
一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。

### 如何决定选用HashMap还是TreeMap

对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。

### ArrayList和Vector有何异同点

ArrayList和Vector在很多时候都很类似。 
（1）两者都是基于索引的，内部由一个数组支持。 
（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。 
（3）ArrayList和Vector的迭代器实现都是fail-fast的。 
（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。 
以下是ArrayList和Vector的不同点。 
（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 
（2）ArrayList比Vector快，它因为有同步，不会过载。 
（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。

### Array和ArrayList有何区别？什么时候更适合用Array

Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 
Array是指定大小的，而ArrayList大小是固定的。 
Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。 
（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。 
（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。 
（3）如果你要使用多维数组，使用[][]比List
